<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>

<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.ComponentModel.Design" #>
<#@ output extension=".cs" #><#

    var resxItem = GetResxProjectItem();
    var resxPath = resxItem.FileNames[0];
    var rootNamespace = GetRootNamespace(resxItem);
    var localNamespace = GetLocalNamespace(resxItem);
    var className = Path.GetFileNameWithoutExtension(resxPath).Replace(".", "_");
    var baseName = localNamespace + "." + className;

    using (var reader = new ResXResourceReader(resxPath) {UseResXDataNodes = true, BasePath=Path.GetDirectoryName(resxPath)})
    {
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// 
// This template generates PublicResXFileCodeGenerator compatible code plus some
// useful extensions. 
// 
// The original version provided by ResXResourceManager is restricted to resource key names
// that are valid c# identifiers to keep this template simple (KISS!).
// 
// Us it as it is or as a scaffold to generate the code you need.
//
// As long as you have ResXResourceManager running in the background, the generated code 
// will be kept up to date.
//  
//------------------------------------------------------------------------------

namespace <#= localNamespace #> {

    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by a text template.
    // To add or remove a member, edit your .ResX file.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ResXResourceManager", "1.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class <#= className #> : global::Localization.ICultural, global::System.ComponentModel.INotifyPropertyChanged {

        private static readonly global::System.Lazy<<#= className #>> LazyInstance = new global::System.Lazy<<#= className #>>(() => new <#= className #>());

        /// <summary>
        ///   Instance of this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static <#= className #> Instance => LazyInstance.Value;
        
        #nullable enable
        public event global::System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

        private void OnResourceCultureChanged()
        {
            this.PropertyChanged?.Invoke(this, new global::System.ComponentModel.PropertyChangedEventArgs(null));
        }
        
        /// <summary>
        ///   Returns ResourceManager instance.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public global::System.Resources.ResourceManager ResourceManager { get; private set; }
        
        #nullable enable
        private global::System.Globalization.CultureInfo? ResourceCulture;

        /// <summary>
        ///   Returns Culture instance or null.
        /// </summary>
        #nullable enable
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public global::System.Globalization.CultureInfo? Culture
        {
            get
            {
                return this.ResourceCulture;
            }
            set
            {
                if (this.ResourceCulture == value)
                {
                    return;
                }
                this.ResourceCulture = value;
                this.OnResourceCultureChanged();
            }
        }
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        private <#= className #>() {
            //this.ResourceManager = new global::System.Resources.ResourceManager("<#= baseName #>", typeof(<#= className #>).Assembly);
            this.ResourceManager = new global::Localization.ResourceManagerX("<#= rootNamespace #>.resources.dll", "<#= baseName #>", typeof(<#= className #>));
            ((global::Localization.ICulturalManager) global::System.Windows.Application.Current).AddCultural(this);
        }

        public string this[string key]
        {
            get
            {
                return this.ResourceManager.GetString(key, this.Culture) ?? string.Empty;
            }
        }
<#
        foreach (var node in GetResxNodes(reader))
        {
            if (node.Type == typeof (string))
            {
#>

        /// <summary>
        ///   Looks up a localized string similar to "<#= XmlEscape(node.Value, 50) #>"
        /// </summary>
<# InsertRemarks(node.Comment); #>
        public string <#= node.Name #>
        {
            get
            {
                return this.ResourceManager.GetString("<#= node.Key #>", this.Culture) ?? string.Empty;
            }
        }
<#
            }
            else
            {
#>

        /// <summary>
        ///   Looks up a localized resource of type <#= node.Type.FullName #>.
        /// </summary>
<# InsertRemarks(node.Comment); #>
        public <#= node.Type.FullName #> <#= node.Name #>
        {
            get
            {
                object obj = this.ResourceManager.GetObject("<#= node.Key #>", this.Culture)!;
                return ((<#= node.Type.FullName #>)(obj));
            }
        }
<#
            }
        }
#>
    }
<#
    }
#>

}
<#+
    ProjectItem GetResxProjectItem()
    {
        var serviceProvider = (IServiceProvider)Host;
        var dte = (DTE2)serviceProvider.GetCOMService(typeof(DTE));
        var ttItem = dte.Solution.FindProjectItem(Host.TemplateFile);
        return (ProjectItem)ttItem.Collection.Parent;
    }

    string GetRootNamespace(ProjectItem resxItem)
    {
        var project = resxItem.ContainingProject;
        return project.Properties.Item("RootNamespace").Value.ToString();
    }

    string GetLocalNamespace(ProjectItem resxItem)
    {
        var resxPath = resxItem.FileNames[0];
        var resxFolder = Path.GetDirectoryName(resxPath);
        var project = resxItem.ContainingProject;
        var projectFolder = Path.GetDirectoryName(project.FullName);
        var rootNamespace = project.Properties.Item("RootNamespace").Value.ToString();

        var localNamespace = rootNamespace;
        if (resxFolder.StartsWith(projectFolder, StringComparison.OrdinalIgnoreCase))
        {
            localNamespace += resxFolder.Substring(projectFolder.Length).Replace('\\', '.');
        }

        return localNamespace;
    }

    void InsertRemarks(string comment)
    {
        if (string.IsNullOrEmpty(comment)) 
            return;

        WriteLine("        /// <remarks>");
        WriteLine("        /// " + XmlEscape(comment));
        WriteLine("        /// </remarks>");
    }

    struct ResxNode
    {
        public string Name;
        public string Key;
        public string Value;
        public string Comment;
        public Type Type;
    }

    IEnumerable<ResxNode> GetResxNodes(ResXResourceReader reader)
    {
        return reader.Cast<DictionaryEntry>()
            .Select(item => (ResXDataNode)item.Value)
            .Select(node => new ResxNode
            {
                Name = Normalize(node.Name),
                Key = node.Name,
                Comment = node.Comment,
                Value = node.GetValue((ITypeResolutionService)null) as string,
                Type = Type.GetType(node.GetValueTypeName((ITypeResolutionService)null))
            })
            .OrderBy(node => node.Key);
    }

    public string Normalize(string value)
    {
        return value
            .Replace(" ", "_")
            .Replace("-", "_")
            .Replace(".", "_")
            .Replace(",", "_")
            .Replace("?", "_")
            .Replace("!", "_");
    }

    public string XmlEscape(string value)
    {
        return value
            .Replace("\n", "&#10;")
            .Replace("\r", "&#13;")
            .Replace(">", "&gt;")
            .Replace("<", "&lt;")
            .Replace("&", "&amp;");
    }

    public string XmlEscape(string value, int maxLen)
    {
        value = XmlEscape(value);
        if (value.Length <= maxLen)
            return value;
        
        return value.Substring(0, maxLen) + "...";
    }

#>